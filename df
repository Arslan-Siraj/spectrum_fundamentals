[1mdiff --git a/spectrum_fundamentals/constants.py b/spectrum_fundamentals/constants.py[m
[1mindex 01650e4..f6bb9d3 100644[m
[1m--- a/spectrum_fundamentals/constants.py[m
[1m+++ b/spectrum_fundamentals/constants.py[m
[36m@@ -162,6 +162,8 @@[m [mMOD_MASSES = {[m
     "[UNIMOD:35]": 15.9949146,  # Oxidation[m
     "[UNIMOD:1]": 42.010565,  # Acetylation[m
     "[UNIMOD:1896]": 158.003765,  # DSSO-crosslinker[m
[32m+[m[32m    "[UNIMOD:1879]": 175.030314,  # Ammonia-quenched monolink of DSSO crosslinker[m
[32m+[m[32m    "[UNIMOD:1878]": 176.014330,  # Water-quenched monolink of DSSO crosslinker[m
     "[UNIMOD:1881]": 54.010565,  # Alkene short fragment of DSSO-crosslinker[m
     "[UNIMOD:1882]": 85.982635,  # Thiol long fragment of DSSO-crosslinker[m
     "[UNIMOD:1884]": 196.084792,  # BuUrBu (DSBU)-crosslinker[m
[1mdiff --git a/spectrum_fundamentals/metrics/fragments_ratio.py b/spectrum_fundamentals/metrics/fragments_ratio.py[m
[1mindex 4113e19..f1281d5 100644[m
[1m--- a/spectrum_fundamentals/metrics/fragments_ratio.py[m
[1m+++ b/spectrum_fundamentals/metrics/fragments_ratio.py[m
[36m@@ -427,10 +427,10 @@[m [mclass FragmentsRatio(Metric):[m
             self.metrics_val["fraction_not_observed_but_predicted_b_b_vs_predicted_b"] = ([m
                 self.metrics_val["count_not_observed_but_predicted_b_b"] / num_predicted_ions_b_b[m
             )[m
[31m-            self.metrics_val["fraction_not_observed_but_predicted_y_a_vs_predicted"] = ([m
[32m+[m[32m            self.metrics_val["fraction_not_observed_but_predicted_y_a_vs_predicted_a"] = ([m
                 self.metrics_val["count_not_observed_but_predicted_y_a"] / num_predicted_ions_y_a[m
             )[m
[31m-            self.metrics_val["fraction_not_observed_but_predicted_y_b_vs_predicted"] = ([m
[32m+[m[32m            self.metrics_val["fraction_not_observed_but_predicted_y_b_vs_predicted_b"] = ([m
                 self.metrics_val["count_not_observed_but_predicted_y_b"] / num_predicted_ions_y_b[m
             )[m
         else:[m
[1mdiff --git a/spectrum_fundamentals/metrics/percolator.py b/spectrum_fundamentals/metrics/percolator.py[m
[1mindex 1b2153c..7a58b0d 100644[m
[1m--- a/spectrum_fundamentals/metrics/percolator.py[m
[1m+++ b/spectrum_fundamentals/metrics/percolator.py[m
[36m@@ -292,6 +292,7 @@[m [mclass Percolator(Metric):[m
     def add_common_features(self):[m
         """Add features used by both Andromeda and Prosit feature scoring sets."""[m
         if any(self.config.search_type.lower() == s.lower() for s in ["plink2", "xlinkx","xisearch"]):[m
[32m+[m[32m            """[m
             self.metrics_val["missedCleavages_A"] = self.metadata["SEQUENCE_A"].apply(Percolator.count_missed_cleavages)[m
             self.metrics_val["missedCleavages_B"] = self.metadata["SEQUENCE_B"].apply(Percolator.count_missed_cleavages)[m
             self.metrics_val["KR_A"] = self.metadata["SEQUENCE_A"].apply(Percolator.count_arginines_and_lysines)[m
[36m@@ -300,6 +301,21 @@[m [mclass Percolator(Metric):[m
             self.metrics_val["sequence_length_b"] = self.metadata["SEQUENCE_B"].apply(lambda x: len(x))[m
             self.metrics_val["Mass_A"] = self.metadata["CALCULATED_MASS_A"]  # this is the calculated mass of cross-linked peptide used as a feature[m
             self.metrics_val["Mass_B"] = self.metadata["CALCULATED_MASS_B"]  # this is the calculated mass of cross-linked peptide used as a feature[m
[32m+[m[32m            self.metrics_val["Peptide_A_decoy"] = self.metadata["Peptide_A_decoy"][m
[32m+[m[32m            self.metrics_val["Peptide_B_decoy"] = self.metadata["Peptide_B_decoy"][m
[32m+[m[32m            self.metrics_val["protein_p1"] = self.metadata["protein_p1"][m
[32m+[m[32m            self.metrics_val["protein_p2"] = self.metadata["protein_p2"][m
[32m+[m[32m            """[m
[32m+[m[32m            self.metrics_val["missedCleavages_A"] = self.metadata["SEQUENCE_A"].apply(Percolator.count_missed_cleavages)[m
[32m+[m[32m            self.metrics_val["missedCleavages_B"] = self.metadata["SEQUENCE_B"].apply(Percolator.count_missed_cleavages)[m
[32m+[m[32m            self.metrics_val["KR_A"] = self.metadata["SEQUENCE_A"].apply(Percolator.count_arginines_and_lysines)[m
[32m+[m[32m            self.metrics_val["KR_B"] = self.metadata["SEQUENCE_B"].apply(Percolator.count_arginines_and_lysines)[m
[32m+[m[32m            self.metrics_val["sequence_length_a"] = self.metadata["SEQUENCE_A"].apply(lambda x: len(x))[m
[32m+[m[32m            self.metrics_val["sequence_length_b"] = self.metadata["SEQUENCE_B"].apply(lambda x: len(x))[m
[32m+[m[32m            for column_name in self.metadata.columns:[m
[32m+[m[32m                self.metrics_val[column_name] = self.metadata[column_name][m
[32m+[m[41m            [m
[32m+[m
         else:[m
             self.metrics_val["missedCleavages"] = self.metadata["SEQUENCE"].apply(Percolator.count_missed_cleavages)[m
             self.metrics_val["KR"] = self.metadata["SEQUENCE"].apply(Percolator.count_arginines_and_lysines)[m
[36m@@ -473,19 +489,21 @@[m [mclass Percolator(Metric):[m
             self.metrics_val = pd.concat([m
                 [self.metrics_val, fragments_ratio.metrics_val, similarity.metrics_val], axis=1[m
             )[m
[31m-[m
[31m-            lda_failed = False[m
[31m-            idxs_below_lda_fdr = self.apply_lda_and_get_indices_below_fdr(fdr_cutoff=self.fdr_cutoff)[m
[31m-            current_fdr = self.fdr_cutoff[m
[31m-            while len(idxs_below_lda_fdr) == 0:[m
[31m-                current_fdr += 0.01[m
[31m-                idxs_below_lda_fdr = self.apply_lda_and_get_indices_below_fdr(fdr_cutoff=current_fdr)[m
[31m-                if current_fdr >= 0.1:[m
[31m-                    lda_failed = True[m
[31m-                    break[m
             if any(self.config.search_type.lower() == s.lower() for s in ["plink2", "xlinkx","xisearch"]):[m
                 self.metrics_val["collision_energy_aligned"] = self.metadata["COLLISION_ENERGY"] / 100.0[m
             else:[m
[32m+[m[32m                lda_failed = False[m
[32m+[m[32m                idxs_below_lda_fdr = self.apply_lda_and_get_indices_below_fdr(fdr_cutoff=self.fdr_cutoff)[m
[32m+[m[32m                current_fdr = self.fdr_cutoff[m
[32m+[m[32m                while len(idxs_below_lda_fdr) == 0:[m
[32m+[m[32m                    current_fdr += 0.01[m
[32m+[m[32m                    idxs_below_lda_fdr = self.apply_lda_and_get_indices_below_fdr(fdr_cutoff=current_fdr)[m
[32m+[m[32m                    if current_fdr >= 0.1:[m
[32m+[m[32m                        lda_failed = True[m
[32m+[m[32m                        break[m
[32m+[m[32m            #if any(self.config.search_type.lower() == s.lower() for s in ["plink2", "xlinkx","xisearch"]):[m
[32m+[m[32m                #self.metrics_val["collision_energy_aligned"] = self.metadata["COLLISION_ENERGY"] / 100.0[m
[32m+[m[41m            [m
                 if lda_failed:[m
                     sampled_idxs = Percolator.sample_balanced_over_bins(self.metadata[["RETENTION_TIME", "PREDICTED_IRT"]])[m
                 else:[m
[36m@@ -561,4 +579,4 @@[m [mdef spline(knots: int, x: np.ndarray, y: np.ndarray):[m
 def logistic(x: Union[pd.Series, np.ndarray], a: float, b: float, c: float, d: float):[m
     """Calculates logistic regression function."""[m
     exponent = np.clip(-c * (x - d), -700, 700)  # make this stable, i.e. avoid 0.0 or inf[m
[31m-    return a / (1.0 + np.exp(exponent)) + b[m
\ No newline at end of file[m
[32m+[m[32m    return a / (1.0 + np.exp(exponent)) + b[m
